use iters::{PackedIterator};
use vecs::{Packed, Packable};

pub struct PackedZip<T> {
    iters: T
}

pub struct PackedZipMap<I, F> {
    iter: I,
    func: F
}

pub trait IntoPackedZip : Sized {
    fn zip(self) -> PackedZip<Self>;
}

pub trait PackedZippedIterator : ExactSizeIterator + Sized {
    type Scalars : Copy + Sized;
    type Vectors : Copy + Sized;

    fn width(&self) -> usize;

    /// Return the length of this iterator, measured in scalar elements.
    fn scalar_len(&self) -> usize;

    /// Return the current position of this iterator, measured in scalar
    /// elements.
    fn scalar_position(&self) -> usize;

    /// Pack and return a vector containing the next `self.width()` elements
    /// of the iterator, or return None if there aren't enough elements left
    fn next_vectors(&mut self) -> Option<Self::Vectors>;

    /// Pack and return a partially full vector containing upto the next
    /// `self.width()` of the iterator, or None if no elements are left.
    /// Elements which are not filled are instead initialized to default.
    fn next_partials(&mut self, default: Self::Vectors) -> Option<Self::Vectors>;

    /// Pack and return a splatted vector containing the next element
    /// of the iterator, or None if no elements are left.
    fn next_splats(&mut self) -> Option<Self::Vectors>;

    #[inline(always)]
    /// Return an iterator which calls `func` on vectors of elements.
    fn simd_map<B, F>(self, func: F) -> PackedZipMap<Self, F>
        where F : FnMut(Self::Vectors) -> B {
        PackedZipMap {
            iter: self,
            func: func
        }
    }

    #[inline(always)]
    /// Return a vector generated by reducing `func` over accumulator `start`
    /// and the values of this iterator, initializing all vectors to `default`
    /// before populating them with elements of the iterator.
    ///
    /// # Examples
    ///
    /// ```
    /// extern crate faster;
    /// use faster::*;
    ///
    /// # fn main() {
    /// let reduced = (&[2.0f32; 100][..]).simd_iter()
    ///    .simd_reduce(f32s::splat(0.0), f32s::splat(0.0), |acc, v| *acc + *v);
    /// # }
    /// ```
    ///
    /// In this example, on a machine with 4-element vectors, the argument to
    /// the last call of the closure is
    ///
    /// ```rust,ignore
    /// [ 2.0 | 2.0 | 2.0 | 2.0 ]
    /// ```
    ///
    /// and the result of the reduction is
    ///
    /// ```rust,ignore
    /// [ 50.0 | 50.0 | 50.0 | 50.0 ]
    /// ```
    ///
    /// whereas on a machine with 8-element vectors, the last call is passed
    ///
    /// ```rust,ignore
    /// [ 2.0 | 2.0 | 2.0 | 2.0 | 0.0 | 0.0 | 0.0 | 0.0 ]
    /// ```
    ///
    /// and the result of the reduction is
    ///
    /// ```rust,ignore
    /// [ 26.0 | 26.0 | 26.0 | 26.0 | 24.0 | 24.0 | 24.0 | 24.0 ]
    /// ```
    ///
    /// # Footgun Warning
    ///
    /// The results of `simd_reduce` are not portable, and it is your
    /// responsibility to interepret the result in such a way that the it is
    /// consistent across different architectures. See [`Packed::sum`] and
    /// [`Packed::product`] for built-in functions which may be helpful.
    ///
    /// [`Packed::sum`]: vecs/trait.Packed.html#tymethod.sum
    /// [`Packed::product`]: vecs/trait.Packed.html#tymethod.product
    fn simd_reduce<A, F>(&mut self, start: A, default: Self::Vectors, mut func: F) -> A
        where F : FnMut(A, Self::Vectors) -> A {
        let mut acc: A;
        if let Some(v) = self.next_vectors() {
            acc = func(start, v);
            while let Some(mut v) = self.next_vectors() {
                acc = func(acc, v);
            }
            if let Some(v) = self.next_partials(default) {
                acc = func(acc, v);
            }
            debug_assert!(self.next_partials(default).is_none());
            acc
        } else if let Some(v) = self.next_partials(default) {
            acc = func(start, v);
            while let Some(v) = self.next_partials(default) {
                acc = func(acc, v);
            }
            debug_assert!(self.next_partials(default).is_none());
            acc
        } else {
            start
        }
    }
}

macro_rules! impl_iter_zip {
    (($($a:tt),*), ($($b:tt),*), ($($n:tt),*)) => (
        impl<$($a),*> IntoPackedZip for ($($a),*) where $($a : PackedIterator),* {

            #[inline(always)]
            fn zip(self) -> PackedZip<Self> {
                PackedZip { iters: self }
            }
        }

        // impl<'a, $($a),*> IntoPackedRefMutIterator<'a> for ($(&'a mut $a),*) where $(&'a mut $a : PackedIterator),* {
        //     type Iter = PackedZip<($(&'a mut $a),*)>;

        //     fn simd_iter_mut(&mut self) -> Self::Iter {
        //         PackedZip { iters: self }
        //     }
        // }

        impl<Z, $($a),*> ExactSizeIterator for PackedZip<($($a),*)>
            where $($a : PackedIterator<Scalar = Z, Item = Z>),*, Z : Packable {

            #[inline(always)]
            fn len(&self) -> usize {
                debug_assert!($(self.iters.$n.len() == self.iters.0.len())&&*);
                self.iters.0.len()
            }
        }

        impl<Z, $($a),*> Iterator for PackedZip<($($a),*)>
            where $($a : PackedIterator<Scalar = Z, Item = Z>),*, Z : Packable {
            type Item = ($(<$a as Iterator>::Item),*);

            fn next(&mut self) -> Option<Self::Item> {
                Some(($(self.iters.$n.next()?),*))
            }
        }

        impl<Z, $($a),*> PackedZippedIterator for PackedZip<($($a),*)>
            where $($a : PackedIterator<Scalar = Z, Item = Z>),*, Z : Packable {
            type Vectors = ($($a::Vector),*);
            type Scalars = ($($a::Scalar),*);

            #[inline(always)]
            fn width(&self) -> usize {
                debug_assert!($(self.iters.$n.width() == self.iters.0.width())&&*);
                self.iters.0.width()
            }

            #[inline(always)]
            fn scalar_len(&self) -> usize {
                debug_assert!($(self.iters.$n.scalar_len() == self.iters.0.scalar_len())&&*);
                self.iters.0.scalar_len()
            }

            #[inline(always)]
            fn scalar_position(&self) -> usize {
                debug_assert!($(self.iters.$n.scalar_position() == self.iters.0.scalar_position())&&*);
                self.iters.0.scalar_position()
            }

            #[inline(always)]
            fn next_vectors(&mut self) -> Option<Self::Vectors> {
                Some(($(self.iters.$n.next_vector()?),*))
            }

            #[inline(always)]
            fn next_splats(&mut self) -> Option<Self::Vectors> {
                Some(($($a::Vector::splat(self.iters.$n.next()?)),*))
            }

            #[inline(always)]
            fn next_partials(&mut self, default: Self::Vectors) -> Option<Self::Vectors> {
                Some(($(self.iters.$n.next_partial(default.$n)?),*))
            }
        }
    );
}

impl<I, F, A> Iterator for PackedZipMap<I, F>
    where I : PackedZippedIterator, F : FnMut(I::Vectors) -> A, A : Packed {
    type Item = A::Scalar;

    #[inline(always)]
    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next_splats().map(&mut self.func).map(A::coalesce)
    }
}

impl<I, F, A> ExactSizeIterator for PackedZipMap<I, F>
    where I : PackedZippedIterator, F : FnMut(I::Vectors) -> A, A : Packed {

    #[inline(always)]
    fn len(&self) -> usize {
        self.iter.len()
    }
}

impl<I, F, A> PackedIterator for PackedZipMap<I, F>
    where I : PackedZippedIterator, F : FnMut(I::Vectors) -> A, A : Packed {
    type Vector = A;
    type Scalar = A::Scalar;

    #[inline(always)]
    fn width(&self) -> usize {
        self.iter.width()
    }

    #[inline(always)]
    fn scalar_len(&self) -> usize {
        self.iter.scalar_len()
    }

    #[inline(always)]
    fn scalar_position(&self) -> usize {
        self.iter.scalar_position()
    }

    #[inline(always)]
    fn next_vector(&mut self) -> Option<Self::Vector> {
        self.iter.next_vectors().map(&mut self.func)
    }

    #[inline(always)]
    fn next_partial(&mut self, default: Self::Vector) -> Option<Self::Vector> {
        // TODO: Respect default and return amount in vector
        None
        // self.iter.next_partials(($($a::Vector::default()),*)).map(&self.func)
    }
}


impl_iter_zip!((A, B),
               (AA, BB),
               (0, 1));
impl_iter_zip!((A, B, C),
               (AA, BB, CC),
               (0, 1, 2));
impl_iter_zip!((A, B, C, D),
               (AA, BB, CC, DD),
               (0, 1, 2, 3));
impl_iter_zip!((A, B, C, D, E),
               (AA, BB, CC, DD, EE),
               (0, 1, 2, 3, 4));
impl_iter_zip!((A, B, C, D, E, F),
               (AA, BB, CC, DD, EE, FF),
               (0, 1, 2, 3, 4, 5));
impl_iter_zip!((A, B, C, D, E, F, G),
               (AA, BB, CC, DD, EE, FF, GG),
               (0, 1, 2, 3, 4, 5, 6));
impl_iter_zip!((A, B, C, D, E, F, G, H),
               (AA, BB, CC, DD, EE, FF, GG, HH),
               (0, 1, 2, 3, 4, 5, 6, 7));
impl_iter_zip!((A, B, C, D, E, F, G, H, I),
               (AA, BB, CC, DD, EE, FF, GG, HH, II),
               (0, 1, 2, 3, 4, 5, 6, 7, 8));
impl_iter_zip!((A, B, C, D, E, F, G, H, I, J),
               (AA, BB, CC, DD, EE, FF, GG, HH, II, JJ),
               (0, 1, 2, 3, 4, 5, 6, 7, 8, 9));
impl_iter_zip!((A, B, C, D, E, F, G, H, I, J, K),
               (AA, BB, CC, DD, EE, FF, GG, HH, II, JJ, KK),
               (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
impl_iter_zip!((A, B, C, D, E, F, G, H, I, J, K, L),
               (AA, BB, CC, DD, EE, FF, GG, HH, II, JJ, KK, LL),
               (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11));
impl_iter_zip!((A, B, C, D, E, F, G, H, I, J, K, L, M),
               (AA, BB, CC, DD, EE, FF, GG, HH, II, JJ, KK, LL, MM),
               (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12));
